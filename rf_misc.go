package rf

import (
	r "reflect"
	"runtime"
	"strings"
	"sync"
)

/*
Tiny shortcut for caching arbitrary structures keyed by `reflect.Type`. Any
reflection-based code that involves walking arbitrary structs should use
`rf.Cache` to "compile" a specialized structure optimized for that particular
traversal, and reuse it for subsequent invocations.
*/
type Cache struct {
	sync.Map
	Func func(r.Type) interface{}
}

/*
Gets or creates the structure keyed by the type and generated by `self.Func`,
which must be provided at construction time.
*/
func (self *Cache) Get(key r.Type) interface{} {
	// Susceptible to "thundering herd". An improvement from no caching, but still
	// not ideal.

	val, ok := self.Load(key)
	if !ok {
		if self.Func != nil {
			val = self.Func(key)
		}
		self.Store(key, val)
	}
	return val
}

/*
Zero-cost integer iterator. Usage:

	for range rf.Iter(N) { ... }
	for i := range rf.Iter(N) { ... }

Because `struct{}` is zero-sized, `[]struct{}` is backed by "zerobase"
(see "runtime/malloc.go") and does not allocate. This should perform about as
well as a "normal" counted loop.

This is not reflection related, but exported because it's used internally a
lot.
*/
func Iter(count int) []struct{} {
	return make([]struct{}, count)
}

/*
Same as `reflect.TypeOf(val).Kind()`, but returns `reflect.Invalid` for a nil
input, instead of panicking. Doesn't automatically dereference the input.
*/
func Kind(val interface{}) r.Kind {
	return TypeKind(r.TypeOf(val))
}

/*
Shortcut for `rf.TypeKind(rf.DerefType(val))`. Returns the kind of the provided
value, automatically dereferencing any outer pointer types until it finds a
non-pointer type. If the input is nil, returns `reflect.Invalid`.
*/
func DerefKind(val interface{}) r.Kind {
	return TypeKind(DerefType(val))
}

/*
Same as `reflect.TypeOf`, but dereferences the type, allowing to pass a nil
pointer, which doesn't allocate. The following expressions both produce the
type of `time.Time`, but the second one is cheaper:

	rf.DerefType(time.Time{})       // Allocates.
	rf.DerefType((*time.Time)(nil)) // Doesn't allocate.
*/
func DerefType(val interface{}) r.Type {
	return TypeDeref(r.TypeOf(val))
}

/*
Returns the element type of the provided type, automatically dereferencing
pointer types. If the input is nil, returns nil.
*/
func TypeDeref(typ r.Type) r.Type {
	for typ != nil && typ.Kind() == r.Ptr {
		typ = typ.Elem()
	}
	return typ
}

/*
Shortcut for `rf.ValueDeref(reflect.ValueOf(val))`. Returns the `reflect.Value`
of the input, automatically dereferencing any outer pointers. If any outer
pointers are nil, returns `reflect.Value{}`.
*/
func DerefValue(val interface{}) r.Value {
	return ValueDeref(r.ValueOf(val))
}

/*
Dereferences the provided value until it's no longer a pointer. If the input is
a nil pointer or a pointer to a nil pointer (recursively), this returns
`reflect.Value{}`.
*/
func ValueDeref(val r.Value) r.Value {
	for val.Kind() == r.Ptr {
		if val.IsNil() {
			return r.Value{}
		}
		val = val.Elem()
	}
	return val
}

/*
Shortcut for `rf.TypeElem(reflect.TypeOf(val))`. Returns the element type of the
given value, automatically dereferencing pointer AND slice types, until it
finds the first non-pointer, non-slice type. If the input is nil, returns nil.
*/
func ElemType(val interface{}) r.Type {
	return TypeElem(r.TypeOf(val))
}

/*
Returns the element type of the provided type, automatically dereferencing
pointer AND slice types, until it finds the first non-pointer, non-slice type.
If the input is nil, returns nil.
*/
func TypeElem(typ r.Type) r.Type {
	for typ != nil && (typ.Kind() == r.Ptr || typ.Kind() == r.Slice) {
		typ = typ.Elem()
	}
	return typ
}

/*
Same as `reflect.Value.Type` but "safe" to call on invalid value, in which case
this will return nil. Should be used only when nil output type is acceptable.
*/
func ValueType(val r.Value) r.Type {
	if !val.IsValid() {
		return nil
	}
	return val.Type()
}

/*
Same as `reflect.Type.Kind(val)`, but returns `reflect.Invalid` for a nil input,
instead of panicking. Doesn't automatically dereference the input.
*/
func TypeKind(val r.Type) r.Kind {
	if val == nil {
		return r.Invalid
	}
	return val.Kind()
}

// Returns the name of a given function, if possible. Returns "" for nil.
func FuncName(val interface{}) string {
	if val == nil {
		return ``
	}
	return runtime.FuncForPC(r.ValueOf(val).Pointer()).Name()
}

/*
True if the input is a nil interface or a non-nil interface containing a nil
value. See `rf.IsValueNil`.
*/
func IsNil(val interface{}) bool {
	return val == nil || IsValueNil(r.ValueOf(val))
}

/*
True if the input is invalid or contains a nilable value that is nil.
Automatically dereferences pointers, returning true for a non-nil pointer to a
nil value.
*/
func IsValueNil(val r.Value) bool {
	val = ValueDeref(val)
	return !val.IsValid() || IsKindNilable(val.Kind()) && val.IsNil()
}

/*
True if the input string is empty. Allows to clarify reflection code that checks
the public/private status of struct fields and type methods. Examples
(oversimplified):

	rf.IsPublic(reflect.StructField{}.PkgPath)
	rf.IsPublic(reflect.Method{}.PkgPath)
*/
func IsPublic(pkgPath string) bool { return pkgPath == `` }

/*
Takes a struct field tag and returns its identifier part, following the
"encoding/json" conventions. Ident "-" is converted to "". Usage:

	ident := rf.TagIdent(someField.Tag.Get(`json`))
	ident := rf.TagIdent(someField.Tag.Get(`db`))

Rules:

	json:"ident"         -> "ident"
	json:"ident,<extra>" -> "ident"
	json:"-"             -> ""
	json:"-,<extra>"     -> ""
*/
func TagIdent(tag string) string {
	// TODO: consider validating that the name doesn't contain double quotes.

	index := strings.IndexRune(tag, ',')
	if index >= 0 {
		tag = tag[:index]
	}
	if tag == `-` {
		return ``
	}
	return tag
}

/*
Zeroes the destination of the given pointer, if possible. The input must be
one of:

	* nil interface (nop)
	* nil pointer (nop)
	* non-nil pointer (gets zeroed)
*/
func Zero(ptr interface{}) {
	if ptr == nil {
		return
	}

	val := r.ValueOf(ptr)
	ValidateValueKind(val, r.Ptr)

	if !val.IsNil() {
		val.Elem().Set(r.Zero(val.Type().Elem()))
	}
}

/*
Shortcut for `rf.IsValueZero(reflect.ValueOf(val))`. True if the input is nil or
a zero value of its type. Automatically dereferences the input; an
arbitrarily-nested non-nil pointer to a zero value is considered zero.
*/
func IsZero(val interface{}) bool {
	return val == nil || IsValueZero(r.ValueOf(val))
}

/*
True if the input is nil (as defined by `rf.IsValueNil`) or a zero value of its
type. Automatically dereferences pointers.
*/
func IsValueZero(val r.Value) bool {
	val = ValueDeref(val)
	return IsValueNil(val) || val.IsZero()
}

// True for kinds on which it's safe to call `reflect.Value.IsNil`.
func IsKindNilable(kind r.Kind) bool {
	switch kind {
	case r.Chan, r.Func, r.Interface, r.Map, r.Ptr, r.Slice, r.UnsafePointer:
		return true
	default:
		return false
	}
}

/*
True for the kinds "reflect" considers collections: array, chan, map, slice, or
string. These are the kinds for which it's safe to call `reflect.Value.Len`
without panicking.
*/
func IsKindColl(kind r.Kind) bool {
	switch kind {
	case r.Array, r.Chan, r.Map, r.Slice, r.String:
		return true
	default:
		return false
	}
}

/*
True if the kind of the provided value is a collection. See `rf.IsKindColl` for
further details. Note that this follows `reflect.Value.Len` rather than the
built-in `len` in that pointers to arrays are not considered to be
collections.
*/
func IsColl(val interface{}) bool {
	return IsKindColl(Kind(val))
}

/*
True if the input belongs to one of the kinds "reflect" considers collections
(see `rf.IsKindColl`), and has the length of zero. If the input is a non-nil
interface that describes a nil collection, such as `([]string)(nil)`, this
returns true. If the input is a nil interface, this returns false. Doesn't
automatically dereference the input.
*/
func IsEmptyColl(val interface{}) bool {
	return IsValueEmptyColl(r.ValueOf(val))
}

/*
Variant of `rf.IsEmpty` that takes a `reflect.Value` as input. See `rf.IsEmpty`
for the documentation.
*/
func IsValueEmptyColl(val r.Value) bool {
	return IsKindColl(val.Kind()) && val.Len() == 0
}

/*
Short for "normalize nil". If the input is a non-nil interface whose underlying
value is nil, this normalizes it, returning a nil interface. Otherwise this
returns the input as-is.
*/
func NormNil(val interface{}) interface{} {
	if IsNil(val) {
		return nil
	}
	return val
}

/*
Shortcut for `rf.ValueLen(rf.DerefValue(val))`. Returns the length of the given
value, if possible. If not, returns 0. Automatically dereferences the input.
*/
func Len(val interface{}) int {
	return ValueLen(DerefValue(val))
}

/*
If the provided value is a collection via `rf.IsColl`, returns the result of
calling `reflect.Value.Len`. Otherwise returns 0. Doesn't automatically
dereference the input.
*/
func ValueLen(val r.Value) int {
	if IsKindColl(val.Kind()) {
		return val.Len()
	}
	return 0
}

/*
Shortcut for `reflect.SliceOf(DerefType(val))`. The following expressions are
all equivalent:

	reflect.SliceOf(reflect.TypeOf(``))
	reflect.SliceOf(reflect.TypeOf((*string)(nil)).Elem())
	rf.SliceType(``)
	rf.SliceType((*string)(nil))
*/
func SliceType(val interface{}) r.Type {
	return r.SliceOf(DerefType(val))
}

/*
Shortcut for copying struct field paths, suitable for
`reflect.StructField.Index`. Such copying is required when walking a struct
type to build a collection of fields for later use (such representations should
also be cached via `rf.Cache`).
*/
func CopyPath(src []int) []int {
	if src == nil {
		return nil
	}
	out := make([]int, len(src))
	copy(out, src)
	return out
}

// True if the given field represents an embedded non-pointer struct type. False
// if it's embedded by pointer.
func IsEmbed(val r.StructField) bool {
	return val.Anonymous && val.Type != nil && val.Type.Kind() == r.Struct
}

// Shortcut for `rf.TypeFields(rf.DerefType(typ))`.
func Fields(typ interface{}) []r.StructField {
	return TypeFields(DerefType(typ))
}

/*
Takes a struct type and returns its fields, caching and reusing the resulting
slice for all future calls for each type. The resulting slice or its elements
must not be mutated.
*/
func TypeFields(typ r.Type) []r.StructField {
	if typ == nil {
		return nil
	}
	return typeFieldsCache.Get(TypeDeref(typ)).([]r.StructField)
}
